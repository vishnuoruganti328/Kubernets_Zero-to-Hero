ğŸ§  Kubernetes (K8s) Architecture â€” Detailed Notes
ğŸŒ 1. Overview
Kubernetes is an open-source container orchestration platform designed to automate deployment, scaling, and management of containerized applications.
It follows a master-worker (control plane â€“ node) architecture, managing a cluster of nodes that run applications inside containers (usually Docker or containerd).

ğŸ§© 2. High-Level Architecture
+--------------------------------------------------------------+
|                        Kubernetes Cluster                    |
|                                                              |
|   +--------------------+        +--------------------+       |
|   | Control Plane      |        | Worker Nodes       |       |
|   | (Master Node)      |        | (Minions)          |       |
|   +--------------------+        +--------------------+       |
|   | - API Server       |        | - Kubelet          |       |
|   | - etcd             |        | - Kube Proxy       |       |
|   | - Controller Mgr   |        | - Container Runtime|       |
|   | - Scheduler        |        | - Pods             |       |
|   +--------------------+        +--------------------+       |
+--------------------------------------------------------------+

âš™ï¸ 3. Key Components of Kubernetes Architecture
ğŸ§­ A. Control Plane Components (Master Node)

The control plane manages the clusterâ€™s overall state â€” deciding what runs where, monitoring health, and responding to cluster events.

1. API Server (kube-apiserver)

Acts as the front door to the Kubernetes control plane.
Exposes RESTful APIs used by kubectl, other components, and external clients.
All communication within the cluster goes through the API server.

Performs:
Authentication & authorization
Request validation
Object persistence (talks to etcd)

Command example:
kubectl get pods --all-namespaces

â†’ The request hits the API server, which reads from etcd and returns results.

2. etcd

A distributed, key-value store used as Kubernetesâ€™ single source of truth.
Stores all cluster data: nodes, pods, configs, secrets, etc.
Designed for high availability, consistency, and reliability.
Backup and recovery of etcd = backup and recovery of your cluster state.

Example data stored in etcd:
/api/v1/pods/default/nginx-pod
/api/v1/nodes/node1

3. Controller Manager (kube-controller-manager)

Runs controllers, which are background processes that regulate the clusterâ€™s state.
Each controller watches the cluster state via the API server and makes changes to move the current state closer to the desired state.

Key controllers:
Node Controller â€“ detects node failures
Replication Controller â€“ ensures the correct number of pod replicas
Endpoints Controller â€“ manages Service endpoints
Namespace Controller â€“ handles creation/deletion of namespaces
Think of controllers as â€œloopsâ€ that continuously reconcile actual vs. desired states.

4. Scheduler (kube-scheduler)

Decides which node a newly created pod should run on.

Factors considered:
Resource requirements (CPU, memory)
Node affinity/taints
Workload balancing
Pod anti-affinity
Once scheduled, the decision is recorded in etcd and the Kubelet on that node starts the container.

ğŸ§± B. Node Components (Worker Nodes)

Each worker node runs the actual containerized workloads (Pods).

1. Kubelet

An agent that runs on each node.
Communicates with the API server to:
Receive pod specs (Pod manifests)
Ensure containers are running as defined
Monitors the nodeâ€™s health and resource usage.
Reports back status to the API server.
If a container dies, Kubelet automatically restarts it based on pod definition.

2. Kube Proxy

Manages networking and service discovery on each node.
Maintains network rules (iptables or IPVS) to route traffic to appropriate pod IPs.
Ensures load balancing among pods for a service.

3. Container Runtime

The software that actually runs containers.
Kubernetes supports multiple runtimes:
containerd
CRI-O
Docker (deprecated but still used via shim)
Kubelet interacts with the runtime using the Container Runtime Interface (CRI).

4. Pods

The smallest deployable unit in Kubernetes.
A Pod = 1 or more containers that share:
Network namespace (IP, port space)
Storage volumes
Lifecycle

Example:
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx:latest

ğŸ§© 4. Supporting Components

ğŸ§  Namespaces
Logical partitions within a cluster.
Used for multi-tenancy, resource isolation, or organization.

ğŸ”’ ConfigMaps & Secrets
Store configuration data separately from code.
ConfigMap: non-sensitive key-value pairs.
Secret: base64-encoded sensitive data (passwords, tokens, etc.).

ğŸ§® Services
Abstract a set of Pods and expose them via a stable IP and DNS name.

Types:

ClusterIP (default, internal only)
NodePort (exposed via nodeâ€™s IP)
LoadBalancer (external access)
ExternalName (DNS CNAME)

âš¡ Ingress

Manages HTTP/HTTPS routing into the cluster.
Works with an Ingress Controller (like NGINX or Traefik).

ğŸ“¡ 5. Cluster Communication

API Server â†” etcd â€” stores & retrieves cluster state
API Server â†” Kubelet â€” manages pod lifecycles
Kubelet â†” Container Runtime â€” starts/stops containers
Kube Proxy â€” routes traffic within cluster

ğŸ§® 6. Example Control Flow: Deploying a Pod

User applies a manifest:
kubectl apply -f nginx-pod.yaml

kubectl â†’ sends request to API Server

API Server â†’ stores desired state in etcd

Scheduler â†’ picks a suitable node

Kubelet (on that node) â†’ pulls image, runs container

Kube Proxy â†’ sets up networking so the Pod is reachable

System continuously monitors & reconciles state

ğŸ§° 7. Add-ons and Ecosystem Components

DNS (CoreDNS): internal service discovery

Metrics Server: collects cluster-wide metrics

Dashboard: web UI for cluster management

Network Plugins (CNI): e.g., Calico, Flannel, Cilium

Storage Plugins (CSI): manage persistent volumes

ğŸ§± 8. Cluster Types

Single-node cluster â€“ for testing (Minikube, Kind, k3s)

Multi-node cluster â€“ production setup

Managed clusters â€“ e.g. GKE, EKS, AKS

ğŸ§­ 9. Summary Diagram
Control Plane (Master)
  â”œâ”€â”€ API Server <----> etcd
  â”œâ”€â”€ Scheduler
  â””â”€â”€ Controller Manager
         â†‘
         â”‚
         â”‚   (communicates via API)
         â†“
Worker Nodes
  â”œâ”€â”€ Kubelet
  â”œâ”€â”€ Kube Proxy
  â”œâ”€â”€ Container Runtime
  â””â”€â”€ Pods

ğŸ”‘ 10. Key Concepts to Remember
Concept	Description
Pod	Smallest deployable unit
Node	Machine (VM or physical) that runs Pods
Control Plane	Cluster brain â€“ makes global decisions
Service	Stable endpoint for Pod groups
etcd	Cluster state database
Kubelet	Node-level agent
Kube Proxy	Handles networking & load balancing
Scheduler	Assigns Pods to Nodes
Controller Manager	Enforces desired cluster state
